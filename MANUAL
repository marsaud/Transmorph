====== Transmorph Manual ======
 

Transmorph is a software component written in PHP 5. Its purpose is to provide data structure transformation and processing, driven by "rules" in a special format.

All necessary documentation for development with Transmorph is available in the source code documentation, which respects PhpDocumentor format.

This manual documents the transformation rule format, Transmorph lies onto.

===== The transformation rule format =====


A transformation rule consists of a //read-rule// linked to a //write-rule// with the '>>' symbol surrounded by single white spaces.

<code>
read-rule >> write-rule
</code>

Transmorph exploits the read-rules to read values out of input data structures, optionally process these values, and finally uses the linked write-rules to write the final values in an output data structure.

The read-rule handling is done by a sub-component called Transmorph_Reader, the write-rule handling is done by a sub-component called Transmorph_Writer.

==== The read-rules ====


A read-rule can be of 3 types :
  * Constant rule.
  * Simple read-rule.
  * Complex read-rule.

=== Constant rule ===


A constant rule consists of '\' symbol followed by a value.

<code>
\constant-value
</code>

A constant rule is evaluated as the value written after the '\'.

=== Simple read-rule ===


A simple read-rule consists of a path the Transmorph_Reader will follow to get a value in a PHP variable we will call the "input".
The path is written by a sequence of rule nodes.
the rule nodes are of 2 kinds :

  * Array nodes :

<code>
/array-key
</code>

  * Object nodes :

<code>
.object-property
</code>

Starting at the "top" of a the input, Transmorph_Reader will follow the sequence of rule nodes by trying to evaluate array keys or object attributes depending on the type of rule node encountered.
When there are no more rule nodes left, Transmorph_Reader returns its last evaluation.

=== Complex read-rule ===


Complex read-rules provide data processing based on callbacks. A complex read-rule consists of a callback name followed by a pair of parenthesis encapsulating a coma separated list of parameters.

<code>
callback(parameter1,parameter2,...)
</code>

The point is on parameters. A parameter is...a read-rule. Any of constant, simple or complex read-rule. Complex read-rules stacking is not functionally limited.

==== The write rules ====


A write-rule consists of a path the Transmorph_Writer will follow to write values in a PHP variable we will call the "output".
The path is written by a sequence of rule nodes.
the rule nodes are of 2 kinds :

  * Array nodes :

<code>
/array-key
</code>

  * Object nodes :

<code>
.object-property
</code>

Starting at the "top" of a the output, Transmorph_Writer will follow the sequence of rule nodes, creating, if necessary, array keys or object attributes depending on the type of rule node encountered.
When there are no more rule nodes left, Transmorph_Writer writes a value in the last encountered/created node.

==== Examples ====


=== Example 1 : simple read-rule with array rule-nodes ===


  * The input :

<code php>
array(4) {
  [0]=>
  string(4) "zero"
  [1]=>
  string(3) "one"
  ["one"]=>
  int(1)
  ["two"]=>
  int(2)
}
</code>

  * The rules :

<code>
/0 >> /A
/1 >> /B
/one >> /C
/two >> /D
</code>

  * The output :

<code php>
array(4) {
  ["A"]=>
  string(4) "zero"
  ["B"]=>
  string(3) "one"
  ["C"]=>
  int(1)
  ["D"]=>
  int(2)
}
</code>

=== Example 2 : simple read-rule with object rule-nodes ===


  * The input :

<code php>
object(stdClass)#1 (2) {
  ["one"]=>
  int(1)
  ["two"]=>
  int(2)
}
</code>

  * The rules :

<code>
.one >> .lower
.two >> .upper
</code>

  * The output :

<code php>
object(stdClass)#6 (2) {
  ["lower"]=>
  int(1)
  ["upper"]=>
  int(2)
}
</code>

=== Example 3 : array nodes, object nodes and constant rule ===


  * The input :

<code php>
object(stdClass)#1 (2) {
  ["first"]=>
  array(2) {
    [0]=>
    string(4) "zero"
    [1]=>
    string(3) "one"
  }
  ["second"]=>
  array(1) {
    [3]=>
    string(5) "three"
  }
}
</code>

  * The rules :

<code>
.first/0 >> /a.foo
.first/1 >> /a.bar
\2 >> /b.baz
.second/3 >> /b.zzz
</code>

  * The output :

<code php>
array(2) {
  ["a"]=>
  object(stdClass)#6 (2) {
    ["foo"]=>
    string(4) "zero"
    ["bar"]=>
    string(3) "one"
  }
  ["b"]=>
  object(stdClass)#7 (2) {
    ["baz"]=>
    string(1) "2"
    ["zzz"]=>
    string(5) "three"
  }
}
</code>

=== Example 4 : complex read-rule with callbacks ===


  * The input :

<code php>
object(stdClass)#1 (2) {
  ["words"]=>
  array(3) {
    [0]=>
    string(4) "From"
    [1]=>
    string(5) "Input"
    [2]=>
    string(6) "Output"
  }
  ["numbers"]=>
  array(1) {
    ["single"]=>
    int(1)
  }
}
</code>

  * The callbacks :

<code php>
function double($i)
{
    return $i * 2;
}

function concat($a, $b)
{
    return $a . $b;
}
</code>

  * The rules :

<code>
concat(concat(.words/0,.words/1),concat(double(.numbers/single),.words/2)) >> .sentence
</code>

  * The output :

<code php>
object(stdClass)#6 (1) {
  ["sentence"]=>
  string(16) "FromInput2Output"
}
</code>